import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";

import { prisma } from "@vectorless/db";

const sectionSchema = z.object({
  id: z.string().optional(),
  sectionType: z.string(),
  markdown: z.string().optional().default("")
});

const payloadSchema = z.object({
  sections: z.array(sectionSchema)
});

interface RouteParams {
  params: { id: string };
}

export async function PUT(request: NextRequest, { params }: RouteParams) {
  const body = await request.json();
  const parsed = payloadSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }

  const run = await prisma.researchRun.findUnique({ where: { id: params.id } });
  if (!run) {
    return NextResponse.json({ error: "Run not found" }, { status: 404 });
  }

  await prisma.$transaction(async (tx) => {
    for (const [index, section] of parsed.data.sections.entries()) {
      if (section.id) {
        await tx.reportSection.update({
          where: { id: section.id, runId: run.id },
          data: {
            content: {
              markdown: section.markdown
            },
            position: index,
            editedByUser: true
          }
        });
        continue;
      }

      await tx.reportSection.create({
        data: {
          runId: run.id,
          sectionType: section.sectionType as any,
          position: index,
          autogenerated: false,
          editedByUser: true,
          content: {
            markdown: section.markdown
          }
        }
      });
    }
  });

  const updated = await prisma.reportSection.findMany({
    where: { runId: run.id },
    orderBy: { position: "asc" }
  });

  return NextResponse.json({ sections: updated });
}

