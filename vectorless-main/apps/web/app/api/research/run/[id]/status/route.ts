import { NextResponse } from "next/server";

import { prisma } from "@vectorless/db";

import { openai } from "@/lib/openai";
import { extractOutputText } from "@/lib/orchestrator";

interface RouteParams {
  params: { id: string };
}

export async function GET(_request: Request, { params }: RouteParams) {
  const run = await prisma.researchRun.findUnique({
    where: { id: params.id },
    include: {
      progressEvents: {
        orderBy: { createdAt: "desc" },
        take: 20
      }
    }
  });

  if (!run) {
    return NextResponse.json({ error: "Run not found" }, { status: 404 });
  }

  let responseSummary: { status: string; outputText?: string } | null = null;

  if (run.backgroundJobId) {
    try {
      const response = await openai.responses.retrieve(run.backgroundJobId);
      const outputText =
        response.status === "completed" ? extractOutputText(response) : undefined;
      responseSummary = {
        status: response.status ?? "unknown",
        outputText
      };

      if (response.status === "completed" && run.status !== "COMPLETED" && outputText) {
        await prisma.$transaction(async (tx) => {
          const existingSections = await tx.reportSection.count({
            where: { runId: run.id }
          });

          if (existingSections === 0) {
            await tx.reportSection.create({
              data: {
                runId: run.id,
                sectionType: "EXECUTIVE_SUMMARY",
                content: {
                  markdown: outputText
                },
                position: 0,
                autogenerated: true
              }
            });
          }

          await tx.researchRun.update({
            where: { id: run.id },
            data: {
              status: "COMPLETED",
              orchestratorPhase: "report"
            }
          });

          await tx.progressEvent.create({
            data: {
              runId: run.id,
              phase: "report",
              message: "Deep Research completed",
              progress: 95
            }
          });
        });
      }
    } catch (error) {
      responseSummary = {
        status: `error: ${(error as Error).message}`
      };
    }
  }

  return NextResponse.json({
    run,
    response: responseSummary
  });
}

